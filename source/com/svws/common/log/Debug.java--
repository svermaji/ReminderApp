package com.svws.common.log;

import java.util.Date;
import java.io.*;

import com.svws.common.UserContext;
import com.svws.common.BasicContextManager;
import com.svws.common.CommonPaths;
import com.svws.common.utils.*;
import com.svws.web.UserSession;

/**
 * Created by
 * User: sverma
 * Date: Feb 21, 2006
 * Time: 11:31:16 AM
 */
/**
 * This class is being to log the information
 * used for debugging purpose
 */
public class Debug
{

    private static Thread reloadThread;
    private static Writer logWriter = null;
    public static final String WARNING = "WARNING";
    public static final String ERROR = "ERROR";
    public static final String INFO = "INFO";
    private static String fullPath = "";

    /**
     * Initialized the logger with file name.
     *
     * @param logFile name of the log file
     * @throws IOException on error
     */
    public static void initialize ( String logFile ) throws IOException
    {
        final String LOGINFO = LogInfo.getLogInfo ( "Debug", "initialize" );
        String logFileName = "svws.log";
        if (StringUtils.hasValue ( logFile ))
        {
            logFileName = logFile;
            write (INFO, LOGINFO  + "Log file created from ServletContext settings with name as logFileName = " + logFileName );
        }

        if (logWriter == null)
        {
            try
            {
                fullPath = BasicContextManager.getRealPath ( logFileName );
                //fullPath = "E:\\i312\\tomcat\\webapps\\svws\\resources\\logs\\svws.log";
                logWriter = new BufferedWriter( new FileWriter( fullPath ) );
                write(INFO, LOGINFO + "log file created with name [" + logFileName + "] on [" + new Date() + "] and full path is [" + fullPath + "]" );
            }
            catch (IOException e)
            {
                logWriter = null;
                write(ERROR, LOGINFO + e.getMessage (), e );
                throw new IOException (e.getMessage ());
            }
            catch (Exception e)
            {
                logWriter = null;
                write(ERROR, LOGINFO + e.getMessage (), e );
            }

            int reloadTime = BasicContextManager.getValueOfReloadProperty ();
            //int reloadTime = 1;
            Debug.write (Debug.INFO, LOGINFO + "Reload time obtained as [" + reloadTime + "]");

            startReloadThread (reloadTime);
        }
    }


    /**
     * Overloaded method.
     *
     * @param prefix
     * @param message
     */
    public static void write ( String prefix, String message )
    {
        write (prefix, message, null);
    }

    /**
     * Writes the debug statement in log file.
     * If log file could not be initialized
     * thn output would be redirected to console.
     *
     * @param prefix - ERROR or INFO
     * @param message - debug statement
     * @param t - throwable object
     */
    public static void write ( String prefix, String message, Throwable t)
    {
        try
        {
            StringBuffer sb = new StringBuffer ("[" + DateUtils.getFormattedDate(UtilConstants.DATE_FORMAT_DD_MMM_YYYY_HH_MM_SS) + "][" + getLoggedUserName () + "][" + CommonPaths.getClientIP () + "]: " + message );
            String errLog = "";

            if (t != null)
                errLog = getStackTrace (t);

            if (logWriter != null)
            {
                synchronized ( logWriter )
                {
                    logWriter.write ( "[" + prefix + "]" + sb.toString () + errLog + "\r\n");
                    logWriter.flush ();
                }
            }
            else
            {
                if (prefix.equals ( Debug.ERROR ))
                {
                    System.out.println (Debug.class.toString () + prefix + ": " + sb.toString () + getStackTrace (t));
                }
                else
                {
                    System.out.println (Debug.class.toString () + prefix + ": " + sb.toString ());
                }
            }
        }
        catch (ProcessingException e)
        {
            e.printStackTrace ();
        }
        catch (Exception e)
        {
            e.printStackTrace ();
        }

    }

    /**
     * Check file size of log file so that
     * if file size exceeds the limit then
     * refreshes the log system.
     */
    private static void checkFileSize () throws ProcessingException
    {
        final String LOGINFO = LogInfo.getLogInfo ( "Debug", "checkFileSize" );

        if (logWriter == null || !StringUtils.hasValue ( fullPath ))
            throw new ProcessingException (LOGINFO + "logWriter is null. Can not shift logs");

        File logFile =  new File (fullPath);
        long mb = 1024 * 1024;
        //long mb = 100 * 1024;
        int logFileSizeInMB = Integer.parseInt ((String) BasicContextManager.getServletContextParamVal (ServletConstants.REFRESH_LOG_FILE_AT_SIZE_IN_MB, new Integer(2)));
        //int logFileSizeInMB = 1;
        long checkFileLength = logFileSizeInMB * mb;

        if (logFile != null && logFile.exists () && logFile.length () > checkFileLength)
        {
            String bkFileName = fullPath + ".1";
            File bkFile = new File (bkFileName);
            if (bkFile.exists ())
            {
                write (Debug.INFO, LOGINFO + "About to delete file [" + bkFile.getName () + "]");
                boolean deleted = bkFile.delete ();
                if (deleted)
                    write (Debug.INFO, LOGINFO + "Deleted old backup file with name [" + bkFile.getName () + "]");
                else
                    write (Debug.ERROR, LOGINFO + "Unable to delete old backup file with name [" + bkFile.getName () + "]");
            }

            write (Debug.INFO, LOGINFO + "backup file object created with name [" + bkFile.getName () + "]");
            boolean renamed = false;
            try
            {
                synchronized ( logWriter )
                {
                    logWriter.close ();
                    renamed = logFile.renameTo ( bkFile );
                    logWriter = new BufferedWriter( new FileWriter( fullPath ) );
                    if (renamed)
                        write (Debug.INFO, LOGINFO + "Renamed file [" + logFile.getName () + "] to name [" + bkFile.getName () + "]");
                    else
                        write (Debug.ERROR, LOGINFO + "Unable to rename file [" + logFile.getName () + "] to name [" + bkFile.getName () + "]");
                }
            }
            catch (Exception e)
            {
                logWriter = null;
                write (Debug.ERROR, LOGINFO + "Unable to rename file [" + logFile.getName () + "] to name [" + bkFile.getName () + "]", e);
            }
        }
        else
            write (Debug.INFO, LOGINFO + "No need to shift the logs as file size [" + logFile.length () + "] is less than [" + checkFileLength + "].");
    }

    /**
     * Returs stacktrace as string for throwable object.
     * In case throwable object is null returns empty string.
     *
     * @param t - throwable object
     * @return string
     */
    private static String getStackTrace ( Throwable t )
    {
        if (t == null)
            return "";
        StringWriter sw = new StringWriter( );
        PrintWriter pw = new PrintWriter( sw );
        t.printStackTrace( pw );
        return( sw.toString() );
    }


    /**
     * Obtain currently logged in user.
     * Returns "" (empty string) if no user is found.
     *
     * @return logged user name
     */
    private static String getLoggedUserName ()
    {
        final String LOGINFO = LogInfo.getLogInfo ( "Debug", "getLoggedUserName" );
        String loginName = "";
        UserContext userContext = null;
        try
        {
            userContext = UserContext.getInstance ();
        }
        catch ( Exception e )
        {
            System.out.println ( ERROR + LOGINFO + "[" + e.getMessage () + "]" + getStackTrace ( e ));
        }

        if (userContext != null)
        {
            if (StringUtils.hasValue ( userContext.getUserName () ))
            {
                loginName = userContext.getUserName ( );
            }
        }
        
        if (!StringUtils.hasValue (loginName))
        {
            //if (UserSession.getUserSession ( BasicContextManager.))
        }

        return loginName;
    }

    /**
     * start the reload thread
     *
     * @param reloadInterval
     */
    private static synchronized void startReloadThread(long reloadInterval) {
        final String LOGINFO = LogInfo.getLogInfo ("Debug", "startReloadThread" );
        // Start the background reload thread.
        if (reloadThread == null) {
            Debug.write ( Debug.INFO, LOGINFO + "Creating reloadThread first time for interval [" + reloadInterval + "] minutes");
            reloadThread = new Thread(new ReloadThread(reloadInterval));
            Debug.write ( Debug.INFO, LOGINFO + "Thread created. Setting Daemon...");
            reloadThread.setDaemon(true);
            Debug.write ( Debug.INFO, LOGINFO + "Thread set to be Daemon. Starting thread...");
            reloadThread.start();
            Debug.write ( Debug.INFO, LOGINFO + "Thread started.");
        }
    }

    /**
     * Inner ReloadThread class
     */
    private static class ReloadThread implements Runnable
    {
        private long reloadInterval = 5;
        private static final long MSEC_PER_MINUTE = 60 * 1000;

        /**
         * Constructor
         *
         * @param reloadInterval
         */
        public ReloadThread(long reloadInterval) {
            final String LOGINFO = LogInfo.getLogInfo ("Debug.ReloadThread", "constructor" );
            if (reloadInterval < 5)
            {
                Debug.write ( Debug.INFO, LOGINFO + "Parameter reloadInterval passed as [" + reloadInterval + "].");
                Debug.write ( Debug.INFO, LOGINFO + "As it is less than 5 minutes, setting reloadInterval to 5.");
                this.reloadInterval = MSEC_PER_MINUTE * 5;
            }
            else
                this.reloadInterval = MSEC_PER_MINUTE * reloadInterval;

            //this.reloadInterval = MSEC_PER_MINUTE * 1;
        }

        /**
         * run method
         */
        public void run()
        {
            final String LOGINFO = LogInfo.getLogInfo ("Debug.ReloadThread", "run" );
            try
            {
                do
                {
                    Debug.write ( Debug.INFO, LOGINFO + "Thread is about to sleep for interval [" + reloadInterval + "] msec i.e [" + (reloadInterval / MSEC_PER_MINUTE) + "] mins.");
                    Thread.sleep(reloadInterval);
                    Debug.write ( Debug.INFO, LOGINFO + "Thread is awake after interval [" + reloadInterval + "] msec i.e [" + (reloadInterval / MSEC_PER_MINUTE) + "] mins.");
                    if (Thread.currentThread().isInterrupted())
                    {
                        Debug.write ( Debug.INFO, LOGINFO + "Thread interrupted. Breaking loop...");
                        break;
                    }
                    Debug.write (Debug.INFO, LOGINFO + "Analysing logs to shift.");
                    checkFileSize ();
                    Debug.write (Debug.INFO, LOGINFO + "Analysis completed.");
                } while (true);
            }
            catch (Exception e)
            {
                String msg = LOGINFO + e.getMessage ();
                Debug.write ( Debug.ERROR, msg, e);
            }
        }
    }

    /**
     * test.
     *
     * @param args string arr
     */
    public static void main ( String[] args ) throws Exception
    {
        initialize ( "/resources/logs/svws.log" );
        for (int i = 0; i < 20000; i++)
            write (INFO, "Logging test statement.");
    }
}